{"version":3,"sources":["../node_modules/hot-pockets/index.js","browser/setParams.js","browser/connectAll.js","../../../../.nvm/versions/node/v8.3.0/lib/node_modules/parcel-bundler/node_modules/events/events.js","../node_modules/beat-emitter/index.js","../node_modules/tunajs/tuna.js","browser/rand.js","browser/noise.js","browser/sonogram.js","browser/scope.js","browser/wave.js","browser/osc-scope.js","browser/viz.js","browser/main.js"],"names":["audioParamProperties","module","exports","setParams","node","params","Object","keys","forEach","value","key","indexOf","delta","connectAll","args","i","length","connect","obj","values","inRange","min","max","Math","floor","random","from","percentRange","percent","range","hp","require","rand","ac","dest","beats","tuna","schedule","chorus","Chorus","filter","createBiquadFilter","type","frequency","gain","phaser","Phaser","rate","depth","feedback","stereoPhase","baseModulationFrequency","bypass","pingPongDelay","PingPongDelay","convolver","Convolver","highCut","lowCut","dryLevel","wetLevel","level","volume","createGain","limiter","createDynamicsCompressor","threshold","knee","ratio","attack","release","inputNode","noiseBuffer","createNoiseBuffer","len","buffer","createBuffer","sampleRate","data","getChannelData","createNoiseSource","createBufferSource","detune","loop","start","currentTime","setValueAtTime","linearRampToValueAtTime","clearSchedule","info","bpm","secondsPerBeat","delay","delayTimeLeft","delayTimeRight","playbackRate","presets","time","param","cancelScheduledValues","exponentialRampToValueAtTime","beatsUntilChange","beat","createNode","fftSize","smoothing","createAnalyser","smoothingTimeConstant","createRenderFunc","canvas","Uint8Array","frequencyBinCount","context","getContext","width","height","getByteFrequencyData","prev","getImageData","putImageData","bandHeight","y","val","fillStyle","fillRect","binCount","lineWidth","strokeStyle","beginPath","sliceWidth","v","x","moveTo","lineTo","stroke","MINVAL","findFirstPositiveZeroCrossing","buf","buflen","last_zero","t","getByteTimeDomainData","sum","abs","avg","mid","avgRatio","size","maxRatio","maxSize","c","zeroCross","j","sonogram","scope","wave","oscScope","setup","sonogramNode","sonogramCanvas","document","createElement","style","body","appendChild","scopeNode","scopeCanvas","waveNode","waveCanvas","oscNode","oscCanvas","nodes","input","all","n","startRenderLoop","animFrameId","cancelAnimationFrame","renderSonogram","renderScope","renderWave","renderOscScope","render","requestAnimationFrame","beatEmitter","Tuna","noise","AudioContext","setBpm","destination","panLeft","Panner","pan","panRight","viz","vizNodes","mixer","createMixer","disconnect","noise2","updateMixer","names","nodesByKey","gainsByKey","transitionTime","zero"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA,IAAMA,uBAAuB,CAC3B,QAD2B,EAE3B,WAF2B,EAG3B,QAH2B,EAI3B,WAJ2B,EAK3B,MAL2B,EAM3B,MAN2B,EAO3B,KAP2B,EAQ3B,cAR2B,EAS3B,OAT2B,EAU3B,WAV2B,EAW3B,SAX2B,EAY3B,WAZ2B,EAa3B,GAb2B,CAA7B;;AAgBAC,OAAOC,OAAP,GAAiB,SAASC,SAAT,CAAoBC,IAApB,EAA0BC,MAA1B,EAAkC;AACjDC,SAAOC,IAAP,CAAYF,MAAZ,EAAoBG,OAApB,CAA4B,eAAO;AACjC,QAAMC,QAAQJ,OAAOK,GAAP,CAAd;AACA,QAAIV,qBAAqBW,OAArB,CAA6BD,GAA7B,KAAqC,CAAzC,EAA4C;AAC1CN,WAAKM,GAAL,EAAUD,KAAV,GAAkBA,KAAlB;AACD,KAFD,MAEO;AACLL,WAAKM,GAAL,IAAYD,KAAZ;AACD;AACF,GAPD;;AASA,SAAOL,IAAP;AACD,CAXD;;AAaAH,OAAOC,OAAP,CAAeU,KAAf,GAAuB,SAASA,KAAT,CAAgBR,IAAhB,EAAsBC,MAAtB,EAA8B;AACnDC,SAAOC,IAAP,CAAYF,MAAZ,EAAoBG,OAApB,CAA4B,eAAO;AACjC,QAAMC,QAAQJ,OAAOK,GAAP,CAAd;AACA,QAAIV,qBAAqBW,OAArB,CAA6BD,GAA7B,KAAqC,CAAzC,EAA4C;AAC1CN,WAAKM,GAAL,EAAUD,KAAV,IAAmBA,KAAnB;AACD,KAFD,MAEO;AACLL,WAAKM,GAAL,KAAaD,KAAb;AACD;AACF,GAPD;;AASA,SAAOL,IAAP;AACD,CAXD;;;;AC9BA,SAASS,UAAT,GAA8B;AAAA,oCAANC,IAAM;AAANA,QAAM;AAAA;;AAC5B,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,KAAKE,MAAL,GAAc,CAAlC,EAAqCD,KAAK,CAA1C,EAA6C;AAC3CD,SAAKC,CAAL,EAAQE,OAAR,CAAgBH,KAAKC,IAAI,CAAT,CAAhB;AACD;;AAED,SAAOD,KAAK,CAAL,CAAP;AACD;;AAEDD,WAAWK,GAAX,GAAiB,UAAUA,GAAV,EAAe;AAC9BL,iDAAcP,OAAOa,MAAP,CAAcD,GAAd,CAAd;AACA,SAAOA,GAAP;AACD,CAHD;;AAKAjB,OAAOC,OAAP,GAAiBW,UAAjB;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9pEA;;AAEA,SAASO,OAAT,CAAkBC,GAAlB,EAAuBC,GAAvB,EAA4B;AAC1B,SAAOC,KAAKC,KAAL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","file":"2b4ffeb7da7f12d12bc43b71fda0bb57.map","sourcesContent":["// browser: do nothing\n\nmodule.exports = function (func) {\n  func()\n}\n","// https://github.com/benji6/virtual-audio-graph/blob/master/src/data.ts\nconst audioParamProperties = [\n  'attack',\n  'delayTime',\n  'detune',\n  'frequency',\n  'gain',\n  'knee',\n  'pan',\n  'playbackRate',\n  'ratio',\n  'reduction',\n  'release',\n  'threshold',\n  'Q',\n]\n\nmodule.exports = function setParams (node, params) {\n  Object.keys(params).forEach(key => {\n    const value = params[key]\n    if (audioParamProperties.indexOf(key) >= 0) {\n      node[key].value = value\n    } else {\n      node[key] = value\n    }\n  })\n  \n  return node\n}\n\nmodule.exports.delta = function delta (node, params) {\n  Object.keys(params).forEach(key => {\n    const value = params[key]\n    if (audioParamProperties.indexOf(key) >= 0) {\n      node[key].value += value\n    } else {\n      node[key] += value\n    }\n  })\n  \n  return node\n}\n","function connectAll (...args) {\n  for (var i = 0; i < args.length - 1; i += 1) {\n    args[i].connect(args[i + 1])\n  }\n\n  return args[0]\n}\n\nconnectAll.obj = function (obj) {\n  connectAll(...Object.values(obj))\n  return obj\n}\n\nmodule.exports = connectAll\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","// with credits to https://github.com/cwilso/metronome\n\nconst EventEmitter = require('events')\n\nfunction worker () {\n  let timerId\n\n  self.onmessage = function (e) {\n\t  if (e.data === 'start') {\n      timerId = setInterval(postMessage.bind(null, 'tick'), 25)\n\t  } else if (e.data === 'stop') {\n\t\t  clearInterval(timerId)\n\t\t  timerId = null\n\t  }\n  }\n}\n\nfunction funcToString (func) {\n  return func.toString().replace(/^[\\w\\W]*?\\{([\\w\\W]*)\\}[\\w\\W]*$/, '$1')\n}\n\nmodule.exports = function (ac) {\n  const emitter = new EventEmitter()\n\n  // how far ahead to schedule\n  const scheduleAheadTime = 0.1\n  let currentBeat = 0\n  let nextBeatTime = 0.0\n  let bpm = 60\n  let secondsPerBeat = 60.0 / bpm\n\n  const w = new Worker(URL.createObjectURL(new Blob(\n    [ funcToString(worker) ], \n    { type: 'application/javascript' }\n  )))\n\n  w.onmessage = function (e) {\n    if (e.data === 'tick') { onTick() }\n  }\n\n  return {\n    setBpm: function (value) {\n      bpm = value\n      secondsPerBeat = 60.0 / bpm\n    },\n\n    info: function () {\n      return {\n        bpm,\n        secondsPerBeat\n      }\n    },\n\n    start: function () {\n      currentNote = 0\n      nextNoteTime = ac.currentTime\n      w.postMessage('start')\n    },\n\n    stop: function () {\n      w.postMessage('stop')\n    },\n\n    emitter,\n    schedule: (func) => {\n      emitter.on('schedule', func)\n      return func\n    },\n    clearSchedule: emitter.removeListener.bind(emitter, 'schedule')\n  }\n\n  // ----\n\n  function onTick () {\n    while (nextBeatTime < ac.currentTime + scheduleAheadTime) {\n      emitter.emit('schedule', currentBeat, nextBeatTime)\n      nextBeatTime += secondsPerBeat\n      currentBeat++\n    }\n  }\n}\n","/*\n    Copyright (c) 2012 DinahMoe AB & Oskar Eriksson\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\n    modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n    is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/*global module*/\n(function() {\n\n    var userContext,\n        userInstance,\n        pipe = function(param, val) {\n            param.value = val;\n        },\n        Super = Object.create(null, {\n            activate: {\n                writable: true,\n                value: function(doActivate) {\n                    if (doActivate) {\n                        this.input.disconnect();\n                        this.input.connect(this.activateNode);\n                        if (this.activateCallback) {\n                            this.activateCallback(doActivate);\n                        }\n                    } else {\n                        this.input.disconnect();\n                        this.input.connect(this.output);\n                    }\n                }\n            },\n            bypass: {\n                get: function() {\n                    return this._bypass;\n                },\n                set: function(value) {\n                    if (this._lastBypassValue === value) {\n                        return;\n                    }\n                    this._bypass = value;\n                    this.activate(!value);\n                    this._lastBypassValue = value;\n                }\n            },\n            connect: {\n                value: function(target) {\n                    this.output.connect(target);\n                }\n            },\n            disconnect: {\n                value: function(target) {\n                    this.output.disconnect(target);\n                }\n            },\n            connectInOrder: {\n                value: function(nodeArray) {\n                    var i = nodeArray.length - 1;\n                    while (i--) {\n                        if (!nodeArray[i].connect) {\n                            return console.error(\"AudioNode.connectInOrder: TypeError: Not an AudioNode.\", nodeArray[i]);\n                        }\n                        if (nodeArray[i + 1].input) {\n                            nodeArray[i].connect(nodeArray[i + 1].input);\n                        } else {\n                            nodeArray[i].connect(nodeArray[i + 1]);\n                        }\n                    }\n                }\n            },\n            getDefaults: {\n                value: function() {\n                    var result = {};\n                    for (var key in this.defaults) {\n                        result[key] = this.defaults[key].value;\n                    }\n                    return result;\n                }\n            },\n            automate: {\n                value: function(property, value, duration, startTime) {\n                    var start = startTime ? ~~(startTime / 1000) : userContext.currentTime,\n                        dur = duration ? ~~(duration / 1000) : 0,\n                        _is = this.defaults[property],\n                        param = this[property],\n                        method;\n\n                    if (param) {\n                        if (_is.automatable) {\n                            if (!duration) {\n                                method = \"setValueAtTime\";\n                            } else {\n                                method = \"linearRampToValueAtTime\";\n                                param.cancelScheduledValues(start);\n                                param.setValueAtTime(param.value, start);\n                            }\n                            param[method](value, dur + start);\n                        } else {\n                            param = value;\n                        }\n                    } else {\n                        console.error(\"Invalid Property for \" + this.name);\n                    }\n                }\n            }\n        }),\n        FLOAT = \"float\",\n        BOOLEAN = \"boolean\",\n        STRING = \"string\",\n        INT = \"int\";\n\n    if (typeof module !== \"undefined\" && module.exports) {\n        module.exports = Tuna;\n    } else if (typeof define === \"function\") {\n        window.define(\"Tuna\", definition);\n    } else {\n        window.Tuna = Tuna;\n    }\n\n    function definition() {\n        return Tuna;\n    }\n\n    function Tuna(context) {\n        if (!(this instanceof Tuna)) {\n            return new Tuna(context);\n        }\n\n        var _window = typeof window === 'undefined' ? {} : window;\n\n        if (!_window.AudioContext) {\n            _window.AudioContext = _window.webkitAudioContext;\n        }\n        if (!context) {\n            console.log(\"tuna.js: Missing audio context! Creating a new context for you.\");\n            context = _window.AudioContext && (new _window.AudioContext());\n        }\n        if (!context) {\n            throw new Error(\"Tuna cannot initialize because this environment does not support web audio.\");\n        }\n        connectify(context);\n        userContext = context;\n        userInstance = this;\n    }\n\n    function connectify(context) {\n        if (context.__connectified__ === true) return;\n\n        var gain = context.createGain(),\n            proto = Object.getPrototypeOf(Object.getPrototypeOf(gain)),\n            oconnect = proto.connect;\n\n        proto.connect = shimConnect;\n        context.__connectified__ = true; // Prevent overriding connect more than once\n\n        function shimConnect() {\n            var node = arguments[0];\n            arguments[0] = Super.isPrototypeOf ? (Super.isPrototypeOf(node) ? node.input : node) : (node.input || node);\n            oconnect.apply(this, arguments);\n            return node;\n        }\n    }\n\n    function dbToWAVolume(db) {\n        return Math.max(0, Math.round(100 * Math.pow(2, db / 6)) / 100);\n    }\n\n    function fmod(x, y) {\n        // http://kevin.vanzonneveld.net\n        // *     example 1: fmod(5.7, 1.3);\n        // *     returns 1: 0.5\n        var tmp, tmp2, p = 0,\n            pY = 0,\n            l = 0.0,\n            l2 = 0.0;\n\n        tmp = x.toExponential().match(/^.\\.?(.*)e(.+)$/);\n        p = parseInt(tmp[2], 10) - (tmp[1] + \"\").length;\n        tmp = y.toExponential().match(/^.\\.?(.*)e(.+)$/);\n        pY = parseInt(tmp[2], 10) - (tmp[1] + \"\").length;\n\n        if (pY > p) {\n            p = pY;\n        }\n\n        tmp2 = (x % y);\n\n        if (p < -100 || p > 20) {\n            // toFixed will give an out of bound error so we fix it like this:\n            l = Math.round(Math.log(tmp2) / Math.log(10));\n            l2 = Math.pow(10, l);\n\n            return (tmp2 / l2).toFixed(l - p) * l2;\n        } else {\n            return parseFloat(tmp2.toFixed(-p));\n        }\n    }\n\n    function sign(x) {\n        if (x === 0) {\n            return 1;\n        } else {\n            return Math.abs(x) / x;\n        }\n    }\n\n    function tanh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / (Math.exp(n) + Math.exp(-n));\n    }\n\n    function initValue(userVal, defaultVal) {\n        return userVal === undefined ? defaultVal : userVal;\n    }\n\n    Tuna.prototype.Bitcrusher = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.bufferSize = properties.bufferSize || this.defaults.bufferSize.value;\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.processor = userContext.createScriptProcessor(this.bufferSize, 1, 1);\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.processor);\n        this.processor.connect(this.output);\n\n        var phaser = 0,\n            last = 0,\n            input, output, step, i, length;\n        this.processor.onaudioprocess = function(e) {\n            input = e.inputBuffer.getChannelData(0),\n            output = e.outputBuffer.getChannelData(0),\n            step = Math.pow(1 / 2, this.bits);\n            length = input.length;\n            for (i = 0; i < length; i++) {\n                phaser += this.normfreq;\n                if (phaser >= 1.0) {\n                    phaser -= 1.0;\n                    last = step * Math.floor(input[i] / step + 0.5);\n                }\n                output[i] = last;\n            }\n        };\n\n        this.bits = properties.bits || this.defaults.bits.value;\n        this.normfreq = initValue(properties.normfreq, this.defaults.normfreq.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Bitcrusher.prototype = Object.create(Super, {\n        name: {\n            value: \"Bitcrusher\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bits: {\n                    value: 4,\n                    min: 1,\n                    max: 16,\n                    automatable: false,\n                    type: INT\n                },\n                bufferSize: {\n                    value: 4096,\n                    min: 256,\n                    max: 16384,\n                    automatable: false,\n                    type: INT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                normfreq: {\n                    value: 0.1,\n                    min: 0.0001,\n                    max: 1.0,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        bits: {\n            enumerable: true,\n            get: function() {\n                return this.processor.bits;\n            },\n            set: function(value) {\n                this.processor.bits = value;\n            }\n        },\n        normfreq: {\n            enumerable: true,\n            get: function() {\n                return this.processor.normfreq;\n            },\n            set: function(value) {\n                this.processor.normfreq = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Cabinet = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.convolver = this.newConvolver(properties.impulsePath || \"../impulses/impulse_guitar.wav\");\n        this.makeupNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.convolver.input);\n        this.convolver.output.connect(this.makeupNode);\n        this.makeupNode.connect(this.output);\n\n        this.makeupGain = initValue(properties.makeupGain, this.defaults.makeupGain);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Cabinet.prototype = Object.create(Super, {\n        name: {\n            value: \"Cabinet\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                makeupGain: {\n                    value: 1,\n                    min: 0,\n                    max: 20,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        makeupGain: {\n            enumerable: true,\n            get: function() {\n                return this.makeupNode.gain;\n            },\n            set: function(value) {\n                this.makeupNode.gain.value = value;\n            }\n        },\n        newConvolver: {\n            value: function(impulsePath) {\n                return new userInstance.Convolver({\n                    impulse: impulsePath,\n                    dryLevel: 0,\n                    wetLevel: 1\n                });\n            }\n        }\n    });\n\n    Tuna.prototype.Chorus = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.attenuator = this.activateNode = userContext.createGain();\n        this.splitter = userContext.createChannelSplitter(2);\n        this.delayL = userContext.createDelay();\n        this.delayR = userContext.createDelay();\n        this.feedbackGainNodeLR = userContext.createGain();\n        this.feedbackGainNodeRL = userContext.createGain();\n        this.merger = userContext.createChannelMerger(2);\n        this.output = userContext.createGain();\n\n        this.lfoL = new userInstance.LFO({\n            target: this.delayL.delayTime,\n            callback: pipe\n        });\n        this.lfoR = new userInstance.LFO({\n            target: this.delayR.delayTime,\n            callback: pipe\n        });\n\n        this.input.connect(this.attenuator);\n        this.attenuator.connect(this.output);\n        this.attenuator.connect(this.splitter);\n        this.splitter.connect(this.delayL, 0);\n        this.splitter.connect(this.delayR, 1);\n        this.delayL.connect(this.feedbackGainNodeLR);\n        this.delayR.connect(this.feedbackGainNodeRL);\n        this.feedbackGainNodeLR.connect(this.delayR);\n        this.feedbackGainNodeRL.connect(this.delayL);\n        this.delayL.connect(this.merger, 0, 0);\n        this.delayR.connect(this.merger, 0, 1);\n        this.merger.connect(this.output);\n\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\n        this.rate = initValue(properties.rate, this.defaults.rate.value);\n        this.delay = initValue(properties.delay, this.defaults.delay.value);\n        this.depth = initValue(properties.depth, this.defaults.depth.value);\n        this.lfoR.phase = Math.PI / 2;\n        this.attenuator.gain.value = 0.6934; // 1 / (10 ^ (((20 * log10(3)) / 3) / 20))\n        this.lfoL.activate(true);\n        this.lfoR.activate(true);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Chorus.prototype = Object.create(Super, {\n        name: {\n            value: \"Chorus\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                feedback: {\n                    value: 0.4,\n                    min: 0,\n                    max: 0.95,\n                    automatable: false,\n                    type: FLOAT\n                },\n                delay: {\n                    value: 0.0045,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                depth: {\n                    value: 0.7,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                rate: {\n                    value: 1.5,\n                    min: 0,\n                    max: 8,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        delay: {\n            enumerable: true,\n            get: function() {\n                return this._delay;\n            },\n            set: function(value) {\n                this._delay = 0.0002 * (Math.pow(10, value) * 2);\n                this.lfoL.offset = this._delay;\n                this.lfoR.offset = this._delay;\n                this._depth = this._depth;\n            }\n        },\n        depth: {\n            enumerable: true,\n            get: function() {\n                return this._depth;\n            },\n            set: function(value) {\n                this._depth = value;\n                this.lfoL.oscillation = this._depth * this._delay;\n                this.lfoR.oscillation = this._depth * this._delay;\n            }\n        },\n        feedback: {\n            enumerable: true,\n            get: function() {\n                return this._feedback;\n            },\n            set: function(value) {\n                this._feedback = value;\n                this.feedbackGainNodeLR.gain.value = this._feedback;\n                this.feedbackGainNodeRL.gain.value = this._feedback;\n            }\n        },\n        rate: {\n            enumerable: true,\n            get: function() {\n                return this._rate;\n            },\n            set: function(value) {\n                this._rate = value;\n                this.lfoL.frequency = this._rate;\n                this.lfoR.frequency = this._rate;\n            }\n        }\n    });\n\n    Tuna.prototype.Compressor = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.compNode = this.activateNode = userContext.createDynamicsCompressor();\n        this.makeupNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.compNode.connect(this.makeupNode);\n        this.makeupNode.connect(this.output);\n\n        this.automakeup = initValue(properties.automakeup, this.defaults.automakeup.value);\n        this.makeupGain = initValue(properties.makeupGain, this.defaults.makeupGain.value);\n        this.threshold = initValue(properties.threshold, this.defaults.threshold.value);\n        this.release = initValue(properties.release, this.defaults.release.value);\n        this.attack = initValue(properties.attack, this.defaults.attack.value);\n        this.ratio = properties.ratio || this.defaults.ratio.value;\n        this.knee = initValue(properties.knee, this.defaults.knee.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Compressor.prototype = Object.create(Super, {\n        name: {\n            value: \"Compressor\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                threshold: {\n                    value: -20,\n                    min: -60,\n                    max: 0,\n                    automatable: true,\n                    type: FLOAT\n                },\n                release: {\n                    value: 250,\n                    min: 10,\n                    max: 2000,\n                    automatable: true,\n                    type: FLOAT\n                },\n                makeupGain: {\n                    value: 1,\n                    min: 1,\n                    max: 100,\n                    automatable: true,\n                    type: FLOAT\n                },\n                attack: {\n                    value: 1,\n                    min: 0,\n                    max: 1000,\n                    automatable: true,\n                    type: FLOAT\n                },\n                ratio: {\n                    value: 4,\n                    min: 1,\n                    max: 50,\n                    automatable: true,\n                    type: FLOAT\n                },\n                knee: {\n                    value: 5,\n                    min: 0,\n                    max: 40,\n                    automatable: true,\n                    type: FLOAT\n                },\n                automakeup: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        computeMakeup: {\n            value: function() {\n                var magicCoefficient = 4, // raise me if the output is too hot\n                    c = this.compNode;\n                return -(c.threshold.value - c.threshold.value / c.ratio.value) / magicCoefficient;\n            }\n        },\n        automakeup: {\n            enumerable: true,\n            get: function() {\n                return this._automakeup;\n            },\n            set: function(value) {\n                this._automakeup = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        threshold: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.threshold;\n            },\n            set: function(value) {\n                this.compNode.threshold.value = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        ratio: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.ratio;\n            },\n            set: function(value) {\n                this.compNode.ratio.value = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        knee: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.knee;\n            },\n            set: function(value) {\n                this.compNode.knee.value = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        attack: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.attack;\n            },\n            set: function(value) {\n                this.compNode.attack.value = value / 1000;\n            }\n        },\n        release: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.release;\n            },\n            set: function(value) {\n                this.compNode.release.value = value / 1000;\n            }\n        },\n        makeupGain: {\n            enumerable: true,\n            get: function() {\n                return this.makeupNode.gain;\n            },\n            set: function(value) {\n                this.makeupNode.gain.value = dbToWAVolume(value);\n            }\n        }\n    });\n\n    Tuna.prototype.Convolver = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.convolver = userContext.createConvolver();\n        this.dry = userContext.createGain();\n        this.filterLow = userContext.createBiquadFilter();\n        this.filterHigh = userContext.createBiquadFilter();\n        this.wet = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.filterLow);\n        this.activateNode.connect(this.dry);\n        this.filterLow.connect(this.filterHigh);\n        this.filterHigh.connect(this.convolver);\n        this.convolver.connect(this.wet);\n        this.wet.connect(this.output);\n        this.dry.connect(this.output);\n\n        this.dryLevel = initValue(properties.dryLevel, this.defaults.dryLevel.value);\n        this.wetLevel = initValue(properties.wetLevel, this.defaults.wetLevel.value);\n        this.highCut = properties.highCut || this.defaults.highCut.value;\n        this.buffer = properties.impulse || \"../impulses/ir_rev_short.wav\";\n        this.lowCut = properties.lowCut || this.defaults.lowCut.value;\n        this.level = initValue(properties.level, this.defaults.level.value);\n        this.filterHigh.type = \"lowpass\";\n        this.filterLow.type = \"highpass\";\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Convolver.prototype = Object.create(Super, {\n        name: {\n            value: \"Convolver\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                highCut: {\n                    value: 22050,\n                    min: 20,\n                    max: 22050,\n                    automatable: true,\n                    type: FLOAT\n                },\n                lowCut: {\n                    value: 20,\n                    min: 20,\n                    max: 22050,\n                    automatable: true,\n                    type: FLOAT\n                },\n                dryLevel: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                wetLevel: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                level: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                }\n            }\n        },\n        lowCut: {\n            get: function() {\n                return this.filterLow.frequency;\n            },\n            set: function(value) {\n                this.filterLow.frequency.value = value;\n            }\n        },\n        highCut: {\n            get: function() {\n                return this.filterHigh.frequency;\n            },\n            set: function(value) {\n                this.filterHigh.frequency.value = value;\n            }\n        },\n        level: {\n            get: function() {\n                return this.output.gain;\n            },\n            set: function(value) {\n                this.output.gain.value = value;\n            }\n        },\n        dryLevel: {\n            get: function() {\n                return this.dry.gain;\n            },\n            set: function(value) {\n                this.dry.gain.value = value;\n            }\n        },\n        wetLevel: {\n            get: function() {\n                return this.wet.gain;\n            },\n            set: function(value) {\n                this.wet.gain.value = value;\n            }\n        },\n        buffer: {\n            enumerable: false,\n            get: function() {\n                return this.convolver.buffer;\n            },\n            set: function(impulse) {\n                var convolver = this.convolver,\n                    xhr = new XMLHttpRequest();\n                if (!impulse) {\n                    console.log(\"Tuna.Convolver.setBuffer: Missing impulse path!\");\n                    return;\n                }\n                xhr.open(\"GET\", impulse, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        if (xhr.status < 300 && xhr.status > 199 || xhr.status === 302) {\n                            userContext.decodeAudioData(xhr.response, function(buffer) {\n                                convolver.buffer = buffer;\n                            }, function(e) {\n                                if (e) console.log(\"Tuna.Convolver.setBuffer: Error decoding data\" + e);\n                            });\n                        }\n                    }\n                };\n                xhr.send(null);\n            }\n        }\n    });\n\n    Tuna.prototype.Delay = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.dry = userContext.createGain();\n        this.wet = userContext.createGain();\n        this.filter = userContext.createBiquadFilter();\n        this.delay = userContext.createDelay(10);\n        this.feedbackNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.delay);\n        this.activateNode.connect(this.dry);\n        this.delay.connect(this.filter);\n        this.filter.connect(this.feedbackNode);\n        this.feedbackNode.connect(this.delay);\n        this.feedbackNode.connect(this.wet);\n        this.wet.connect(this.output);\n        this.dry.connect(this.output);\n\n        this.delayTime = properties.delayTime || this.defaults.delayTime.value;\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\n        this.wetLevel = initValue(properties.wetLevel, this.defaults.wetLevel.value);\n        this.dryLevel = initValue(properties.dryLevel, this.defaults.dryLevel.value);\n        this.cutoff = properties.cutoff || this.defaults.cutoff.value;\n        this.filter.type = \"lowpass\";\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Delay.prototype = Object.create(Super, {\n        name: {\n            value: \"Delay\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                delayTime: {\n                    value: 100,\n                    min: 20,\n                    max: 1000,\n                    automatable: false,\n                    type: FLOAT\n                },\n                feedback: {\n                    value: 0.45,\n                    min: 0,\n                    max: 0.9,\n                    automatable: true,\n                    type: FLOAT\n                },\n                cutoff: {\n                    value: 20000,\n                    min: 20,\n                    max: 20000,\n                    automatable: true,\n                    type: FLOAT\n                },\n                wetLevel: {\n                    value: 0.5,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                dryLevel: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                }\n            }\n        },\n        delayTime: {\n            enumerable: true,\n            get: function() {\n                return this.delay.delayTime;\n            },\n            set: function(value) {\n                this.delay.delayTime.value = value / 1000;\n            }\n        },\n        wetLevel: {\n            enumerable: true,\n            get: function() {\n                return this.wet.gain;\n            },\n            set: function(value) {\n                this.wet.gain.value = value;\n            }\n        },\n        dryLevel: {\n            enumerable: true,\n            get: function() {\n                return this.dry.gain;\n            },\n            set: function(value) {\n                this.dry.gain.value = value;\n            }\n        },\n        feedback: {\n            enumerable: true,\n            get: function() {\n                return this.feedbackNode.gain;\n            },\n            set: function(value) {\n                this.feedbackNode.gain.value = value;\n            }\n        },\n        cutoff: {\n            enumerable: true,\n            get: function() {\n                return this.filter.frequency;\n            },\n            set: function(value) {\n                this.filter.frequency.value = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Filter = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.filter = userContext.createBiquadFilter();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.filter);\n        this.filter.connect(this.output);\n\n        this.frequency = properties.frequency || this.defaults.frequency.value;\n        this.Q = properties.resonance || this.defaults.Q.value;\n        this.filterType = initValue(properties.filterType, this.defaults.filterType.value);\n        this.gain = initValue(properties.gain, this.defaults.gain.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Filter.prototype = Object.create(Super, {\n        name: {\n            value: \"Filter\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                frequency: {\n                    value: 800,\n                    min: 20,\n                    max: 22050,\n                    automatable: true,\n                    type: FLOAT\n                },\n                Q: {\n                    value: 1,\n                    min: 0.001,\n                    max: 100,\n                    automatable: true,\n                    type: FLOAT\n                },\n                gain: {\n                    value: 0,\n                    min: -40,\n                    max: 40,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                filterType: {\n                    value: \"lowpass\",\n                    automatable: false,\n                    type: STRING\n                }\n            }\n        },\n        filterType: {\n            enumerable: true,\n            get: function() {\n                return this.filter.type;\n            },\n            set: function(value) {\n                this.filter.type = value;\n            }\n        },\n        Q: {\n            enumerable: true,\n            get: function() {\n                return this.filter.Q;\n            },\n            set: function(value) {\n                this.filter.Q.value = value;\n            }\n        },\n        gain: {\n            enumerable: true,\n            get: function() {\n                return this.filter.gain;\n            },\n            set: function(value) {\n                this.filter.gain.value = value;\n            }\n        },\n        frequency: {\n            enumerable: true,\n            get: function() {\n                return this.filter.frequency;\n            },\n            set: function(value) {\n                this.filter.frequency.value = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Gain = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.gainNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.gainNode);\n        this.gainNode.connect(this.output);\n\n        this.gain = initValue(properties.gain, this.defaults.gain.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Gain.prototype = Object.create(Super, {\n        name: {\n            value: \"Gain\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                gain: {\n                    value: 1.0,\n                    automatable: true,\n                    type: FLOAT\n                }\n            }\n        },\n        gain: {\n            enumerable: true,\n            get: function() {\n                return this.gainNode.gain;\n            },\n            set: function(value) {\n                this.gainNode.gain.value = value;\n            }\n        }\n    });\n\n    Tuna.prototype.MoogFilter = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.bufferSize = properties.bufferSize || this.defaults.bufferSize.value;\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.processor = userContext.createScriptProcessor(this.bufferSize, 1, 1);\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.processor);\n        this.processor.connect(this.output);\n\n        var in1, in2, in3, in4, out1, out2, out3, out4;\n        in1 = in2 = in3 = in4 = out1 = out2 = out3 = out4 = 0.0;\n        var input, output, f, fb, i, length, inputFactor;\n        this.processor.onaudioprocess = function(e) {\n            input = e.inputBuffer.getChannelData(0),\n                output = e.outputBuffer.getChannelData(0),\n                f = this.cutoff * 1.16,\n                inputFactor = 0.35013 * (f * f) * (f * f);\n            fb = this.resonance * (1.0 - 0.15 * f * f);\n            length = input.length;\n            for (i = 0; i < length; i++) {\n                input[i] -= out4 * fb;\n                input[i] *= inputFactor;\n                out1 = input[i] + 0.3 * in1 + (1 - f) * out1; // Pole 1\n                in1 = input[i];\n                out2 = out1 + 0.3 * in2 + (1 - f) * out2; // Pole 2\n                in2 = out1;\n                out3 = out2 + 0.3 * in3 + (1 - f) * out3; // Pole 3\n                in3 = out2;\n                out4 = out3 + 0.3 * in4 + (1 - f) * out4; // Pole 4\n                in4 = out3;\n                output[i] = out4;\n            }\n        };\n\n        this.cutoff = initValue(properties.cutoff, this.defaults.cutoff.value);\n        this.resonance = initValue(properties.resonance, this.defaults.resonance.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.MoogFilter.prototype = Object.create(Super, {\n        name: {\n            value: \"MoogFilter\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bufferSize: {\n                    value: 4096,\n                    min: 256,\n                    max: 16384,\n                    automatable: false,\n                    type: INT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                cutoff: {\n                    value: 0.065,\n                    min: 0.0001,\n                    max: 1.0,\n                    automatable: false,\n                    type: FLOAT\n                },\n                resonance: {\n                    value: 3.5,\n                    min: 0.0,\n                    max: 4.0,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        cutoff: {\n            enumerable: true,\n            get: function() {\n                return this.processor.cutoff;\n            },\n            set: function(value) {\n                this.processor.cutoff = value;\n            }\n        },\n        resonance: {\n            enumerable: true,\n            get: function() {\n                return this.processor.resonance;\n            },\n            set: function(value) {\n                this.processor.resonance = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Overdrive = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.inputDrive = userContext.createGain();\n        this.waveshaper = userContext.createWaveShaper();\n        this.outputDrive = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.inputDrive);\n        this.inputDrive.connect(this.waveshaper);\n        this.waveshaper.connect(this.outputDrive);\n        this.outputDrive.connect(this.output);\n\n        this.ws_table = new Float32Array(this.k_nSamples);\n        this.drive = initValue(properties.drive, this.defaults.drive.value);\n        this.outputGain = initValue(properties.outputGain, this.defaults.outputGain.value);\n        this.curveAmount = initValue(properties.curveAmount, this.defaults.curveAmount.value);\n        this.algorithmIndex = initValue(properties.algorithmIndex, this.defaults.algorithmIndex.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Overdrive.prototype = Object.create(Super, {\n        name: {\n            value: \"Overdrive\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                drive: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT,\n                    scaled: true\n                },\n                outputGain: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT,\n                    scaled: true\n                },\n                curveAmount: {\n                    value: 0.725,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                algorithmIndex: {\n                    value: 0,\n                    min: 0,\n                    max: 5,\n                    automatable: false,\n                    type: INT\n                }\n            }\n        },\n        k_nSamples: {\n            value: 8192\n        },\n        drive: {\n            get: function() {\n                return this.inputDrive.gain;\n            },\n            set: function(value) {\n                this._drive = value;\n            }\n        },\n        curveAmount: {\n            get: function() {\n                return this._curveAmount;\n            },\n            set: function(value) {\n                this._curveAmount = value;\n                if (this._algorithmIndex === undefined) {\n                    this._algorithmIndex = 0;\n                }\n                this.waveshaperAlgorithms[this._algorithmIndex](this._curveAmount, this.k_nSamples, this.ws_table);\n                this.waveshaper.curve = this.ws_table;\n            }\n        },\n        outputGain: {\n            get: function() {\n                return this.outputDrive.gain;\n            },\n            set: function(value) {\n                this._outputGain = dbToWAVolume(value);\n            }\n        },\n        algorithmIndex: {\n            get: function() {\n                return this._algorithmIndex;\n            },\n            set: function(value) {\n                this._algorithmIndex = value;\n                this.curveAmount = this._curveAmount;\n            }\n        },\n        waveshaperAlgorithms: {\n            value: [\n                function(amount, n_samples, ws_table) {\n                    amount = Math.min(amount, 0.9999);\n                    var k = 2 * amount / (1 - amount),\n                        i, x;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        ws_table[i] = (1 + k) * x / (1 + k * Math.abs(x));\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var i, x, y;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        y = ((0.5 * Math.pow((x + 1.4), 2)) - 1) * y >= 0 ? 5.8 : 1.2;\n                        ws_table[i] = tanh(y);\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var i, x, y, a = 1 - amount;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        y = x < 0 ? -Math.pow(Math.abs(x), a + 0.04) : Math.pow(x, a);\n                        ws_table[i] = tanh(y * 2);\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var i, x, y, abx, a = 1 - amount > 0.99 ? 0.99 : 1 - amount;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        abx = Math.abs(x);\n                        if (abx < a) y = abx;\n                        else if (abx > a) y = a + (abx - a) / (1 + Math.pow((abx - a) / (1 - a), 2));\n                        else if (abx > 1) y = abx;\n                        ws_table[i] = sign(x) * y * (1 / ((a + 1) / 2));\n                    }\n                },\n                function(amount, n_samples, ws_table) { // fixed curve, amount doesn't do anything, the distortion is just from the drive\n                    var i, x;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        if (x < -0.08905) {\n                            ws_table[i] = (-3 / 4) * (1 - (Math.pow((1 - (Math.abs(x) - 0.032857)), 12)) + (1 / 3) * (Math.abs(x) - 0.032847)) + 0.01;\n                        } else if (x >= -0.08905 && x < 0.320018) {\n                            ws_table[i] = (-6.153 * (x * x)) + 3.9375 * x;\n                        } else {\n                            ws_table[i] = 0.630035;\n                        }\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var a = 2 + Math.round(amount * 14),\n                        // we go from 2 to 16 bits, keep in mind for the UI\n                        bits = Math.round(Math.pow(2, a - 1)),\n                        // real number of quantization steps divided by 2\n                        i, x;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        ws_table[i] = Math.round(x * bits) / bits;\n                    }\n                }\n            ]\n        }\n    });\n\n    Tuna.prototype.Panner = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.panner = userContext.createStereoPanner();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.panner);\n        this.panner.connect(this.output);\n\n        this.pan = initValue(properties.pan, this.defaults.pan.value);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Panner.prototype = Object.create(Super, {\n        name: {\n            value: \"Panner\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                pan: {\n                    value: 0.0,\n                    min: -1.0,\n                    max: 1.0,\n                    automatable: true,\n                    type: FLOAT\n                }\n            }\n        },\n        pan: {\n            enumerable: true,\n            get: function() {\n                return this.panner.pan;\n            },\n            set: function(value) {\n                this.panner.pan.value = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Phaser = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.splitter = this.activateNode = userContext.createChannelSplitter(2);\n        this.filtersL = [];\n        this.filtersR = [];\n        this.feedbackGainNodeL = userContext.createGain();\n        this.feedbackGainNodeR = userContext.createGain();\n        this.merger = userContext.createChannelMerger(2);\n        this.filteredSignal = userContext.createGain();\n        this.output = userContext.createGain();\n        this.lfoL = new userInstance.LFO({\n            target: this.filtersL,\n            callback: this.callback\n        });\n        this.lfoR = new userInstance.LFO({\n            target: this.filtersR,\n            callback: this.callback\n        });\n\n        var i = this.stage;\n        while (i--) {\n            this.filtersL[i] = userContext.createBiquadFilter();\n            this.filtersR[i] = userContext.createBiquadFilter();\n            this.filtersL[i].type = \"allpass\";\n            this.filtersR[i].type = \"allpass\";\n        }\n        this.input.connect(this.splitter);\n        this.input.connect(this.output);\n        this.splitter.connect(this.filtersL[0], 0, 0);\n        this.splitter.connect(this.filtersR[0], 1, 0);\n        this.connectInOrder(this.filtersL);\n        this.connectInOrder(this.filtersR);\n        this.filtersL[this.stage - 1].connect(this.feedbackGainNodeL);\n        this.filtersL[this.stage - 1].connect(this.merger, 0, 0);\n        this.filtersR[this.stage - 1].connect(this.feedbackGainNodeR);\n        this.filtersR[this.stage - 1].connect(this.merger, 0, 1);\n        this.feedbackGainNodeL.connect(this.filtersL[0]);\n        this.feedbackGainNodeR.connect(this.filtersR[0]);\n        this.merger.connect(this.output);\n\n        this.rate = initValue(properties.rate, this.defaults.rate.value);\n        this.baseModulationFrequency = properties.baseModulationFrequency || this.defaults.baseModulationFrequency.value;\n        this.depth = initValue(properties.depth, this.defaults.depth.value);\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\n        this.stereoPhase = initValue(properties.stereoPhase, this.defaults.stereoPhase.value);\n\n        this.lfoL.activate(true);\n        this.lfoR.activate(true);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Phaser.prototype = Object.create(Super, {\n        name: {\n            value: \"Phaser\"\n        },\n        stage: {\n            value: 4\n        },\n        defaults: {\n            writable: true,\n            value: {\n                rate: {\n                    value: 0.1,\n                    min: 0,\n                    max: 8,\n                    automatable: false,\n                    type: FLOAT\n                },\n                depth: {\n                    value: 0.6,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                feedback: {\n                    value: 0.7,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                stereoPhase: {\n                    value: 40,\n                    min: 0,\n                    max: 180,\n                    automatable: false,\n                    type: FLOAT\n                },\n                baseModulationFrequency: {\n                    value: 700,\n                    min: 500,\n                    max: 1500,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        callback: {\n            value: function(filters, value) {\n                for (var stage = 0; stage < 4; stage++) {\n                    filters[stage].frequency.value = value;\n                }\n            }\n        },\n        depth: {\n            get: function() {\n                return this._depth;\n            },\n            set: function(value) {\n                this._depth = value;\n                this.lfoL.oscillation = this._baseModulationFrequency * this._depth;\n                this.lfoR.oscillation = this._baseModulationFrequency * this._depth;\n            }\n        },\n        rate: {\n            get: function() {\n                return this._rate;\n            },\n            set: function(value) {\n                this._rate = value;\n                this.lfoL.frequency = this._rate;\n                this.lfoR.frequency = this._rate;\n            }\n        },\n        baseModulationFrequency: {\n            enumerable: true,\n            get: function() {\n                return this._baseModulationFrequency;\n            },\n            set: function(value) {\n                this._baseModulationFrequency = value;\n                this.lfoL.offset = this._baseModulationFrequency;\n                this.lfoR.offset = this._baseModulationFrequency;\n                this._depth = this._depth;\n            }\n        },\n        feedback: {\n            get: function() {\n                return this._feedback;\n            },\n            set: function(value) {\n                this._feedback = value;\n                this.feedbackGainNodeL.gain.value = this._feedback;\n                this.feedbackGainNodeR.gain.value = this._feedback;\n            }\n        },\n        stereoPhase: {\n            get: function() {\n                return this._stereoPhase;\n            },\n            set: function(value) {\n                this._stereoPhase = value;\n                var newPhase = this.lfoL._phase + this._stereoPhase * Math.PI / 180;\n                newPhase = fmod(newPhase, 2 * Math.PI);\n                this.lfoR._phase = newPhase;\n            }\n        }\n    });\n\n    Tuna.prototype.PingPongDelay = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.wetLevel = userContext.createGain();\n        this.stereoToMonoMix = userContext.createGain();\n        this.feedbackLevel = userContext.createGain();\n        this.output = userContext.createGain();\n        this.delayLeft = userContext.createDelay(10);\n        this.delayRight = userContext.createDelay(10);\n\n        this.activateNode = userContext.createGain();\n        this.splitter = userContext.createChannelSplitter(2);\n        this.merger = userContext.createChannelMerger(2);\n\n        this.activateNode.connect(this.splitter);\n        this.splitter.connect(this.stereoToMonoMix, 0, 0);\n        this.splitter.connect(this.stereoToMonoMix, 1, 0);\n        this.stereoToMonoMix.gain.value = .5;\n        this.stereoToMonoMix.connect(this.wetLevel);\n        this.wetLevel.connect(this.delayLeft);\n        this.feedbackLevel.connect(this.delayLeft);\n        this.delayLeft.connect(this.delayRight);\n        this.delayRight.connect(this.feedbackLevel);\n        this.delayLeft.connect(this.merger, 0, 0);\n        this.delayRight.connect(this.merger, 0, 1);\n        this.merger.connect(this.output);\n        this.activateNode.connect(this.output);\n\n        this.delayTimeLeft = properties.delayTimeLeft !== undefined ? properties.delayTimeLeft : this.defaults.delayTimeLeft.value;\n        this.delayTimeRight = properties.delayTimeRight !== undefined ? properties.delayTimeRight : this.defaults.delayTimeRight.value;\n        this.feedbackLevel.gain.value = properties.feedback !== undefined ? properties.feedback : this.defaults.feedback.value;\n        this.wetLevel.gain.value = properties.wetLevel !== undefined ? properties.wetLevel : this.defaults.wetLevel.value;\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.PingPongDelay.prototype = Object.create(Super, {\n        name: {\n            value: \"PingPongDelay\"\n        },\n        delayTimeLeft: {\n            enumerable: true,\n            get: function() {\n                return this._delayTimeLeft;\n            },\n            set: function(value) {\n                this._delayTimeLeft = value;\n                this.delayLeft.delayTime.value = value / 1000;\n            }\n        },\n        delayTimeRight: {\n            enumerable: true,\n            get: function() {\n                return this._delayTimeRight;\n            },\n            set: function(value) {\n                this._delayTimeRight = value;\n                this.delayRight.delayTime.value = value / 1000;\n            }\n        },\n        defaults: {\n            writable: true,\n            value: {\n                delayTimeLeft: {\n                    value: 200,\n                    min: 1,\n                    max: 10000,\n                    automatable: false,\n                    type: INT\n                },\n                delayTimeRight: {\n                    value: 400,\n                    min: 1,\n                    max: 10000,\n                    automatable: false,\n                    type: INT\n                },\n                feedback: {\n                    value: 0.3,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                wetLevel: {\n                    value: 0.5,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        }\n    });\n\n    Tuna.prototype.Tremolo = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.splitter = this.activateNode = userContext.createChannelSplitter(\n                2),\n            this.amplitudeL = userContext.createGain(),\n            this.amplitudeR = userContext.createGain(),\n            this.merger = userContext.createChannelMerger(2),\n            this.output = userContext.createGain();\n        this.lfoL = new userInstance.LFO({\n            target: this.amplitudeL.gain,\n            callback: pipe\n        });\n        this.lfoR = new userInstance.LFO({\n            target: this.amplitudeR.gain,\n            callback: pipe\n        });\n\n        this.input.connect(this.splitter);\n        this.splitter.connect(this.amplitudeL, 0);\n        this.splitter.connect(this.amplitudeR, 1);\n        this.amplitudeL.connect(this.merger, 0, 0);\n        this.amplitudeR.connect(this.merger, 0, 1);\n        this.merger.connect(this.output);\n\n        this.rate = properties.rate || this.defaults.rate.value;\n        this.intensity = initValue(properties.intensity, this.defaults.intensity.value);\n        this.stereoPhase = initValue(properties.stereoPhase, this.defaults.stereoPhase.value);\n\n        this.lfoL.offset = 1 - (this.intensity / 2);\n        this.lfoR.offset = 1 - (this.intensity / 2);\n        this.lfoL.phase = this.stereoPhase * Math.PI / 180;\n\n        this.lfoL.activate(true);\n        this.lfoR.activate(true);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.Tremolo.prototype = Object.create(Super, {\n        name: {\n            value: \"Tremolo\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                intensity: {\n                    value: 0.3,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                stereoPhase: {\n                    value: 0,\n                    min: 0,\n                    max: 180,\n                    automatable: false,\n                    type: FLOAT\n                },\n                rate: {\n                    value: 5,\n                    min: 0.1,\n                    max: 11,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        intensity: {\n            enumerable: true,\n            get: function() {\n                return this._intensity;\n            },\n            set: function(value) {\n                this._intensity = value;\n                this.lfoL.offset = 1 - this._intensity / 2;\n                this.lfoR.offset = 1 - this._intensity / 2;\n                this.lfoL.oscillation = this._intensity;\n                this.lfoR.oscillation = this._intensity;\n            }\n        },\n        rate: {\n            enumerable: true,\n            get: function() {\n                return this._rate;\n            },\n            set: function(value) {\n                this._rate = value;\n                this.lfoL.frequency = this._rate;\n                this.lfoR.frequency = this._rate;\n            }\n        },\n        stereoPhase: {\n            enumerable: true,\n            get: function() {\n                return this._stereoPhase;\n            },\n            set: function(value) {\n                this._stereoPhase = value;\n                var newPhase = this.lfoL._phase + this._stereoPhase * Math.PI / 180;\n                newPhase = fmod(newPhase, 2 * Math.PI);\n                this.lfoR.phase = newPhase;\n            }\n        }\n    });\n\n    Tuna.prototype.WahWah = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.envelopeFollower = new userInstance.EnvelopeFollower({\n            target: this,\n            callback: function(context, value) {\n                context.sweep = value;\n            }\n        });\n        this.filterBp = userContext.createBiquadFilter();\n        this.filterPeaking = userContext.createBiquadFilter();\n        this.output = userContext.createGain();\n\n        //Connect AudioNodes\n        this.activateNode.connect(this.filterBp);\n        this.filterBp.connect(this.filterPeaking);\n        this.filterPeaking.connect(this.output);\n\n        //Set Properties\n        this.init();\n        this.automode = initValue(properties.automode, this.defaults.automode.value);\n        this.resonance = properties.resonance || this.defaults.resonance.value;\n        this.sensitivity = initValue(properties.sensitivity, this.defaults.sensitivity.value);\n        this.baseFrequency = initValue(properties.baseFrequency, this.defaults.baseFrequency.value);\n        this.excursionOctaves = properties.excursionOctaves || this.defaults.excursionOctaves.value;\n        this.sweep = initValue(properties.sweep, this.defaults.sweep.value);\n\n        this.activateNode.gain.value = 2;\n        this.envelopeFollower.activate(true);\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.WahWah.prototype = Object.create(Super, {\n        name: {\n            value: \"WahWah\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                automode: {\n                    value: true,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                baseFrequency: {\n                    value: 0.5,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                excursionOctaves: {\n                    value: 2,\n                    min: 1,\n                    max: 6,\n                    automatable: false,\n                    type: FLOAT\n                },\n                sweep: {\n                    value: 0.2,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                resonance: {\n                    value: 10,\n                    min: 1,\n                    max: 100,\n                    automatable: false,\n                    type: FLOAT\n                },\n                sensitivity: {\n                    value: 0.5,\n                    min: -1,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        automode: {\n            get: function() {\n                return this._automode;\n            },\n            set: function(value) {\n                this._automode = value;\n                if (value) {\n                    this.activateNode.connect(this.envelopeFollower.input);\n                    this.envelopeFollower.activate(true);\n                } else {\n                    this.envelopeFollower.activate(false);\n                    this.activateNode.disconnect();\n                    this.activateNode.connect(this.filterBp);\n                }\n            }\n        },\n        filterFreqTimeout: {\n            value: 0\n        },\n        setFilterFreq: {\n            value: function() {\n                try {\n                    this.filterBp.frequency.value = Math.min(22050, this._baseFrequency + this._excursionFrequency * this._sweep);\n                    this.filterPeaking.frequency.value = Math.min(22050, this._baseFrequency + this._excursionFrequency * this._sweep);\n                } catch (e) {\n                    clearTimeout(this.filterFreqTimeout);\n                    //put on the next cycle to let all init properties be set\n                    this.filterFreqTimeout = setTimeout(function() {\n                        this.setFilterFreq();\n                    }.bind(this), 0);\n                }\n            }\n        },\n        sweep: {\n            enumerable: true,\n            get: function() {\n                return this._sweep;\n            },\n            set: function(value) {\n                this._sweep = Math.pow(value > 1 ? 1 : value < 0 ? 0 : value, this._sensitivity);\n                this.setFilterFreq();\n            }\n        },\n        baseFrequency: {\n            enumerable: true,\n            get: function() {\n                return this._baseFrequency;\n            },\n            set: function(value) {\n                this._baseFrequency = 50 * Math.pow(10, value * 2);\n                this._excursionFrequency = Math.min(userContext.sampleRate / 2, this.baseFrequency * Math.pow(2, this._excursionOctaves));\n                this.setFilterFreq();\n            }\n        },\n        excursionOctaves: {\n            enumerable: true,\n            get: function() {\n                return this._excursionOctaves;\n            },\n            set: function(value) {\n                this._excursionOctaves = value;\n                this._excursionFrequency = Math.min(userContext.sampleRate / 2, this.baseFrequency * Math.pow(2, this._excursionOctaves));\n                this.setFilterFreq();\n            }\n        },\n        sensitivity: {\n            enumerable: true,\n            get: function() {\n                return this._sensitivity;\n            },\n            set: function(value) {\n                this._sensitivity = Math.pow(10, value);\n            }\n        },\n        resonance: {\n            enumerable: true,\n            get: function() {\n                return this._resonance;\n            },\n            set: function(value) {\n                this._resonance = value;\n                this.filterPeaking.Q = this._resonance;\n            }\n        },\n        init: {\n            value: function() {\n                this.output.gain.value = 1;\n                this.filterPeaking.type = \"peaking\";\n                this.filterBp.type = \"bandpass\";\n                this.filterPeaking.frequency.value = 100;\n                this.filterPeaking.gain.value = 20;\n                this.filterPeaking.Q.value = 5;\n                this.filterBp.frequency.value = 100;\n                this.filterBp.Q.value = 1;\n            }\n        }\n    });\n\n    Tuna.prototype.EnvelopeFollower = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.jsNode = this.output = userContext.createScriptProcessor(this.buffersize, 1, 1);\n\n        this.input.connect(this.output);\n\n        this.attackTime = initValue(properties.attackTime, this.defaults.attackTime.value);\n        this.releaseTime = initValue(properties.releaseTime, this.defaults.releaseTime.value);\n        this._envelope = 0;\n        this.target = properties.target || {};\n        this.callback = properties.callback || function() {};\n\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.EnvelopeFollower.prototype = Object.create(Super, {\n        name: {\n            value: \"EnvelopeFollower\"\n        },\n        defaults: {\n            value: {\n                attackTime: {\n                    value: 0.003,\n                    min: 0,\n                    max: 0.5,\n                    automatable: false,\n                    type: FLOAT\n                },\n                releaseTime: {\n                    value: 0.5,\n                    min: 0,\n                    max: 0.5,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        buffersize: {\n            value: 256\n        },\n        envelope: {\n            value: 0\n        },\n        sampleRate: {\n            value: 44100\n        },\n        attackTime: {\n            enumerable: true,\n            get: function() {\n                return this._attackTime;\n            },\n            set: function(value) {\n                this._attackTime = value;\n                this._attackC = Math.exp(-1 / this._attackTime * this.sampleRate / this.buffersize);\n            }\n        },\n        releaseTime: {\n            enumerable: true,\n            get: function() {\n                return this._releaseTime;\n            },\n            set: function(value) {\n                this._releaseTime = value;\n                this._releaseC = Math.exp(-1 / this._releaseTime * this.sampleRate / this.buffersize);\n            }\n        },\n        callback: {\n            get: function() {\n                return this._callback;\n            },\n            set: function(value) {\n                if (typeof value === \"function\") {\n                    this._callback = value;\n                } else {\n                    console.error(\"tuna.js: \" + this.name + \": Callback must be a function!\");\n                }\n            }\n        },\n        target: {\n            get: function() {\n                return this._target;\n            },\n            set: function(value) {\n                this._target = value;\n            }\n        },\n        activate: {\n            value: function(doActivate) {\n                this.activated = doActivate;\n                if (doActivate) {\n                    this.jsNode.connect(userContext.destination);\n                    this.jsNode.onaudioprocess = this.returnCompute(this);\n                } else {\n                    this.jsNode.disconnect();\n                    this.jsNode.onaudioprocess = null;\n                }\n                if (this.activateCallback) {\n                    this.activateCallback(doActivate);\n                }\n            }\n        },\n        returnCompute: {\n            value: function(instance) {\n                return function(event) {\n                    instance.compute(event);\n                };\n            }\n        },\n        compute: {\n            value: function(event) {\n                var count = event.inputBuffer.getChannelData(0).length,\n                    channels = event.inputBuffer.numberOfChannels,\n                    current, chan, rms, i;\n                chan = rms = i = 0;\n                if (channels > 1) { //need to mixdown\n                    for (i = 0; i < count; ++i) {\n                        for (; chan < channels; ++chan) {\n                            current = event.inputBuffer.getChannelData(chan)[i];\n                            rms += (current * current) / channels;\n                        }\n                    }\n                } else {\n                    for (i = 0; i < count; ++i) {\n                        current = event.inputBuffer.getChannelData(0)[i];\n                        rms += (current * current);\n                    }\n                }\n                rms = Math.sqrt(rms);\n\n                if (this._envelope < rms) {\n                    this._envelope *= this._attackC;\n                    this._envelope += (1 - this._attackC) * rms;\n                } else {\n                    this._envelope *= this._releaseC;\n                    this._envelope += (1 - this._releaseC) * rms;\n                }\n                this._callback(this._target, this._envelope);\n            }\n        }\n    });\n\n    Tuna.prototype.LFO = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n\n        //Instantiate AudioNode\n        this.input = userContext.createGain();\n        this.output = userContext.createScriptProcessor(256, 1, 1);\n        this.activateNode = userContext.destination;\n\n        //Set Properties\n        this.frequency = initValue(properties.frequency, this.defaults.frequency.value);\n        this.offset = initValue(properties.offset, this.defaults.offset.value);\n        this.oscillation = initValue(properties.oscillation, this.defaults.oscillation.value);\n        this.phase = initValue(properties.phase, this.defaults.phase.value);\n        this.target = properties.target || {};\n        this.output.onaudioprocess = this.callback(properties.callback || function() {});\n        this.bypass = properties.bypass || false;\n    };\n    Tuna.prototype.LFO.prototype = Object.create(Super, {\n        name: {\n            value: \"LFO\"\n        },\n        bufferSize: {\n            value: 256\n        },\n        sampleRate: {\n            value: 44100\n        },\n        defaults: {\n            value: {\n                frequency: {\n                    value: 1,\n                    min: 0,\n                    max: 20,\n                    automatable: false,\n                    type: FLOAT\n                },\n                offset: {\n                    value: 0.85,\n                    min: 0,\n                    max: 22049,\n                    automatable: false,\n                    type: FLOAT\n                },\n                oscillation: {\n                    value: 0.3,\n                    min: -22050,\n                    max: 22050,\n                    automatable: false,\n                    type: FLOAT\n                },\n                phase: {\n                    value: 0,\n                    min: 0,\n                    max: 2 * Math.PI,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        frequency: {\n            get: function() {\n                return this._frequency;\n            },\n            set: function(value) {\n                this._frequency = value;\n                this._phaseInc = 2 * Math.PI * this._frequency * this.bufferSize / this.sampleRate;\n            }\n        },\n        offset: {\n            get: function() {\n                return this._offset;\n            },\n            set: function(value) {\n                this._offset = value;\n            }\n        },\n        oscillation: {\n            get: function() {\n                return this._oscillation;\n            },\n            set: function(value) {\n                this._oscillation = value;\n            }\n        },\n        phase: {\n            get: function() {\n                return this._phase;\n            },\n            set: function(value) {\n                this._phase = value;\n            }\n        },\n        target: {\n            get: function() {\n                return this._target;\n            },\n            set: function(value) {\n                this._target = value;\n            }\n        },\n        activate: {\n            value: function(doActivate) {\n                if (doActivate) {\n                    this.output.connect(userContext.destination);\n                    if (this.activateCallback) {\n                        this.activateCallback(doActivate);\n                    }\n                } else {\n                    this.output.disconnect();\n                }\n            }\n        },\n        callback: {\n            value: function(callback) {\n                var that = this;\n                return function() {\n                    that._phase += that._phaseInc;\n                    if (that._phase > 2 * Math.PI) {\n                        that._phase = 0;\n                    }\n                    callback(that._target, that._offset + that._oscillation * Math.sin(that._phase));\n                };\n            }\n        }\n    });\n\n    Tuna.toString = Tuna.prototype.toString = function() {\n        return \"Please visit https://github.com/Theodeus/tuna/wiki for instructions on how to use Tuna.js\";\n    };\n})();\n","//@hp:pure\n\nfunction inRange (min, max) {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\nfunction from (values) {\n  return values[inRange(0, values.length)]\n}\n\nfunction percentRange (min, max, percent) {\n  const range = max - min\n  return min + (percent * range)\n}\n\nmodule.exports = {\n  inRange,\n  from,\n  percentRange\n}\n","const hp = require('hot-pockets')\nconst setParams = require('./setParams')\nconst connectAll = require('./connectAll')\nconst rand = require('./rand')\n\nmodule.exports = function ({ ac, dest, beats, tuna }) {\n  let schedule\n\n  const chorus = new tuna.Chorus({\n\n  })\n\n  const filter = setParams(ac.createBiquadFilter(), {\n    type: 'lowpass',\n    frequency: 1000,\n    gain: 10\n  })\n\n  const phaser = new tuna.Phaser({\n    rate: 1.2,                     //0.01 to 8 is a decent range, but higher values are possible\n    depth: 0.3,                    //0 to 1\n    feedback: 0.2,                 //0 to 1+\n    stereoPhase: 30,               //0 to 180\n    baseModulationFrequency: 700,  //500 to 1500\n    bypass: 0\n  });\n\n  const pingPongDelay = new tuna.PingPongDelay();\n\n  const convolver = new tuna.Convolver({\n    highCut: 22050,                         //20 to 22050\n    lowCut: 20,                             //20 to 22050\n    dryLevel: 0,                            //0 to 1+\n    wetLevel: 1.5,                            //0 to 1+\n    level: 1,                               //0 to 1+, adjusts total output of both wet and dry\n//    impulse: \"./impulses/ir_rev_short.wav\",    //the path to your impulse response\n    bypass: 0\n  })\n\n  const volume = setParams(ac.createGain(), {\n    gain: 0.0\n  })\n\n  const limiter = setParams(ac.createDynamicsCompressor(), {\n    threshold: -70.0,\n    knee: 0.0,\n    ratio: 10,\n    attack: 0.005,\n    release: 0.050\n  })\n\n  const inputNode = connectAll(\n    chorus,\n    filter,\n    phaser,\n    convolver,\n    pingPongDelay,\n    limiter,\n    volume,\n    dest\n  )\n\n  const noiseBuffer = createNoiseBuffer(ac)\n\n  function createNoiseBuffer (ac) {\n    const len = 4096\n    const buffer = ac.createBuffer(1, len, ac.sampleRate)\n    const data = buffer.getChannelData(0)\n\n    for (var i = 0; i < len; i++) {\n      data[i] = Math.random()\n    }\n    return buffer\n  }\n  \n  function createNoiseSource (ac, params, buffer) {\n    const node = ac.createBufferSource()\n\n    const {\n      detune = 0\n    } = params\n\n    setParams(node, {\n      buffer,\n      detune,\n      loop: true\n    })\n\n    return node\n  }\n\n  const node = createNoiseSource(ac, {}, noiseBuffer)\n  node.start(ac.currentTime)\n  node.connect(inputNode)\n\n  volume.gain.setValueAtTime(0.0001, ac.currentTime)\n  volume.gain.linearRampToValueAtTime(1.0, ac.currentTime + 3)\n\n  hp(() => {\n    // unmount schedule from a previous update\n    if (schedule) { beats.clearSchedule(schedule) }\n\n    const {\n      bpm,\n      secondsPerBeat\n    } = beats.info()\n\n    setParams(limiter, {\n      threshold: -90.0\n    })\n    \n    setParams(filter, {\n      type: 'notch',\n      gain: 10\n    })\n    \n    setParams(chorus, {\n      rate: 5,\n      feedback: .5,\n      delay: .1,\n      bypass: 0\n    })\n\n    setParams(convolver, {\n      wetLevel: 0.8,\n      dryLevel: 0\n    })\n\n    setParams(pingPongDelay, {\n      bypass: 0,\n      wetLevel: 0.9, //0 to 1\n      feedback: 0.7, //0 to 1\n      delayTimeLeft: 500, //1 to 10000 (milliseconds)\n      delayTimeRight: 700 //1 to 10000 (milliseconds)\n    })\n\n    node.playbackRate.value = .2\n\n    const presets = [\n      (time) => {\n        setParams(chorus, {\n          rate: rand.from([1, 5, 20, 50])\n        })\n      },\n\n      (time) => {\n        setParams(chorus, {\n          feedback: rand.from([.1, .2, .8])\n        })\n      },\n\n      (time) => {\n        setParams(chorus, {\n          delay: rand.from([.1, .2, .8, 1.5, 3])\n        })\n      },\n\n      (time) => {\n        setParams(convolver, {\n          wetLevel: rand.from([.1, .2, .8, 1.1])\n        })\n      },\n\n      (time) => {\n        const param = convolver.highCut\n        param.cancelScheduledValues(time)\n        param.exponentialRampToValueAtTime(rand.from([5000, 8000, 15000, 22000]) , time + (secondsPerBeat * rand.inRange(1, 5)))\n      },\n\n      (time) => {\n        const param = convolver.lowCut\n        param.cancelScheduledValues(time)\n        param.exponentialRampToValueAtTime(rand.from([50, 1000, 5000, 8000, 15000]) , time + (secondsPerBeat * rand.inRange(1, 5)))\n      },\n\n      (time) => {\n        filter.type = rand.from(['notch', 'peaking', 'lowpass', 'bandpass', 'lowshelf'])\n\n        const param = filter.frequency\n        param.cancelScheduledValues(time)\n        param.exponentialRampToValueAtTime(rand.from([100, 3000, 7000, 15000]) , time + (secondsPerBeat * rand.inRange(1, 5)))\n      },\n\n      (time) => {\n        const param = node.playbackRate\n        param.cancelScheduledValues(time)\n        param.exponentialRampToValueAtTime(rand.from([.1, .2, .8, 1.5, 3]) , time + (secondsPerBeat * rand.inRange(1, 5)))\n      },\n\n      (time) => {\n        setParams(pingPongDelay, {\n          delayTimeLeft: rand.from([ 300, 500, 2200, 3500 ]),\n          delayTimeRight: rand.from([ 300, 500, 2200, 3500 ])\n        })\n      }\n    ]\n\n    let beatsUntilChange = 0\n    schedule = beats.schedule((beat, time) => {\n      if (beatsUntilChange === 0) {\n        rand.from(presets)(time)\n        beatsUntilChange = rand.from([ 1, 2, 3 ]) * 3\n      } else {\n        beatsUntilChange --\n      }\n    })\n  })\n}\n","// credits: https://github.com/urtzurd/html-audio/blob/gh-pages/static/js/pitch-shifter.js\n\nfunction createNode (ac) {\n  const fftSize = 2048\n  const smoothing = 0\n  const node = ac.createAnalyser()\n\n  node.fftSize = fftSize\n  node.smoothingTimeConstant = smoothing\n\n  return node\n}\n\nfunction createRenderFunc (node, canvas) {\n  const data = new Uint8Array(node.frequencyBinCount)\n  const context = canvas.getContext('2d')\n\n  return function () {\n    const { width, height } = canvas\n\n    node.getByteFrequencyData(data)\n\n    // shift everything 1 px to the left\n    const prev = context.getImageData(1, 0, width - 1, height)\n    context.putImageData(prev, 0, 0)\n\n    const bandHeight = height / data.length\n    for (var i = 0, y = height - 1;\n         i < data.length;\n         i++, y -= bandHeight) {\n\n      var val = data[i]\n      context.fillStyle = `hsl(${val + 150}, 100%, ${(val / 255) * 100}%)`\n      if (val === 0) {\n        context.fillStyle = `hsl(150, 100%, 80%)`\n      }\n      context.fillRect(width - 1, y, 1, -bandHeight)\n    }\n  }\n}\n\nmodule.exports = {\n  createNode,\n  createRenderFunc\n}\n","function createNode (ac) {\n  const node = ac.createAnalyser()\n  node.fftSize = 128\n  return node\n}\n\nfunction createRenderFunc (node, canvas) {\n  const binCount = node.frequencyBinCount\n  const data = new Uint8Array(binCount)\n  const context = canvas.getContext('2d')\n\n  return function () {\n    const { width, height } = canvas\n\n    node.getByteFrequencyData(data)\n\n    context.fillStyle = 'hsla(180, 30%, 80%, 0.4)'\n    context.fillRect(0, 0, width, height)\n\n    context.lineWidth = 2\n    context.strokeStyle = 'hsla(250, 80%, 30%, 1.0)'\n\n    context.beginPath()\n\n    const sliceWidth = height * 1.0 / binCount\n    var y = height - sliceWidth\n\n    for (var i = 0; i < binCount; i++) {\n\n      const v = data[i] / 255.0\n      const x = Math.max(2, width * v)\n\n      context.moveTo(x, y)\n      context.lineTo(x, y + sliceWidth)\n\n      y -= sliceWidth\n    }\n\n    context.stroke()\n  }\n}\n\nmodule.exports = {\n  createNode,\n  createRenderFunc\n}\n","// source: https://webaudiotech.com/sites/limiter_comparison/oscilloscope.js\n\nconst MINVAL = 1234;\t// height/2 == zero.\tMINVAL is the \"minimum detected signal\" level.\n\nfunction findFirstPositiveZeroCrossing(buf, buflen, height) {\n\tvar i = 0;\n\tvar last_zero = -1;\n\tvar t;\n\n\t// advance until we're zero or negative\n\twhile (i<buflen && (buf[i] > height/2 ) )\n\t\ti++;\n\n\tif (i>=buflen)\n\t\treturn 0;\n\n\t// advance until we're above MINVAL, keeping track of last zero.\n\twhile (i<buflen && ((t=buf[i]) < MINVAL )) {\n\t\tif (t >= height/2) {\n\t\t\tif (last_zero == -1)\n\t\t\t\tlast_zero = i;\n\t\t} else\n\t\t\tlast_zero = -1;\n\t\ti++;\n\t}\n\n\t// we may have jumped over MINVAL in one sample.\n\tif (last_zero == -1)\n\t\tlast_zero = i;\n\n\tif (i==buflen)\t// We didn't find any positive zero crossings\n\t\treturn 0;\n\n\t// The first sample might be a zero.\tIf so, return it.\n\tif (last_zero == 0)\n\t\treturn 0;\n\n\treturn last_zero;\n}\n\nfunction createNode (ac) {\n  const node = ac.createAnalyser()\n  node.fftSize = 2048\n  return node\n}\n\nfunction createRenderFunc (node, canvas) {\n  const data = new Uint8Array(canvas.width)\n  const context = canvas.getContext('2d')\n\n  return function () {\n    const { width, height } = canvas\n\n\t  node.getByteTimeDomainData(data);\n//console.log(data)\n    // context.fillStyle = 'hsla(260, 80%, 20%, 0.3)'\n    // context.fillRect(0, 0, width, height)\n\n    // shift everything 1 px to the left\n    const prev = context.getImageData(1, 0, width - 1, height)\n    context.putImageData(prev, 0, 0)\n\n    context.lineWidth = 1\n    context.strokeStyle = 'rgba(255, 255, 255, 0.1)'\n\n    // draw the mid line\n    context.beginPath();\n\t  context.moveTo(0,height/2);\n\t  context.lineTo(width,height/2);\n\t  context.stroke();\n\n    var len = data.length\n    var sum = 0\n    var max = 0\n    for (var i=0; i<len; i++) {\n      sum += data[i]\n\n      var abs = Math.abs(128 - data[i])\n      if (abs > max) { max = abs }\n    }\n\n    const avg = sum / len\n    const mid = height / 2\n    const avgRatio = (128 - avg) / 128\n    const size = avgRatio * mid\n\n    const maxRatio = max / 128\n    const maxSize = maxRatio * mid\n\n    context.fillStyle = `hsl(260, 80%, 20%)`\n    context.fillRect(width - 1, 0, 1, height)\n\n    context.fillStyle = `hsla(90, 100%, 80%, .3)`\n    context.fillRect(width - 2, mid - maxSize, 1, (maxSize * 2))\n\n    context.fillStyle = `hsl(150, 100%, 80%)`\n    context.fillRect(width - 2, mid - size, 1, (size * 2))\n  }\n}\n\nmodule.exports = {\n  createNode,\n  createRenderFunc\n}\n","// source: https://webaudiotech.com/sites/limiter_comparison/oscilloscope.js\n\nconst MINVAL = 1234;\t// height/2 == zero.\tMINVAL is the \"minimum detected signal\" level.\n\nfunction findFirstPositiveZeroCrossing(buf, buflen, height) {\n\tvar i = 0;\n\tvar last_zero = -1;\n\tvar t;\n\n\t// advance until we're zero or negative\n\twhile (i<buflen && (buf[i] > height/2 ) )\n\t\ti++;\n\n\tif (i>=buflen)\n\t\treturn 0;\n\n\t// advance until we're above MINVAL, keeping track of last zero.\n\twhile (i<buflen && ((t=buf[i]) < MINVAL )) {\n\t\tif (t >= height/2) {\n\t\t\tif (last_zero == -1)\n\t\t\t\tlast_zero = i;\n\t\t} else\n\t\t\tlast_zero = -1;\n\t\ti++;\n\t}\n\n\t// we may have jumped over MINVAL in one sample.\n\tif (last_zero == -1)\n\t\tlast_zero = i;\n\n\tif (i==buflen)\t// We didn't find any positive zero crossings\n\t\treturn 0;\n\n\t// The first sample might be a zero.\tIf so, return it.\n\tif (last_zero == 0)\n\t\treturn 0;\n\n\treturn last_zero;\n}\n\nfunction createNode (ac) {\n  const node = ac.createAnalyser()\n  node.fftSize = 1024\n  return node\n}\n\nfunction createRenderFunc (node, canvas) {\n  const data = new Uint8Array(canvas.width)\n  const context = canvas.getContext('2d')\n\n  return function () {\n    const { width, height } = canvas\n\n\t  node.getByteTimeDomainData(data);\n\n    context.fillStyle = 'hsla(250, 80%, 30%, 0.3)'\n    context.fillRect(0, 0, width, height)\n\n    context.lineWidth = 1\n    context.strokeStyle = 'rgba(255, 255, 255, 0.7)'\n\n    // draw the mid line\n    context.beginPath();\n\t  context.moveTo(0,height/2);\n\t  context.lineTo(width,height/2);\n\t  context.stroke();\n\n    // draw the oscilloscope path\n    context.lineWidth = 2\n    context.beginPath()\n    const c = width / (node.fftSize/2)\n\n    var zeroCross = findFirstPositiveZeroCrossing(data, width, height);\n\t  if (zeroCross==0) zeroCross=1;\n    \n\t  for (var i=zeroCross, j=0; j<(width-zeroCross); i++, j++) {\n\t\t  context.lineTo(j,height-( c *data[i]));\n    }\n\n\t  context.stroke();\n  }\n}\n\nmodule.exports = {\n  createNode,\n  createRenderFunc\n}\n","const hp = require('hot-pockets')\nconst sonogram = require('./sonogram')\nconst scope = require('./scope')\nconst wave = require('./wave')\nconst oscScope = require('./osc-scope')\n\nfunction setup (ac) {\n  const sonogramNode = sonogram.createNode(ac)\n  const sonogramCanvas = document.createElement('canvas')\n  sonogramCanvas.style = 'width: 50vw; height: 50vh; background-color: hsl(150, 100%, 80%);'\n  document.body.appendChild(sonogramCanvas)\n\n  // ----\n\n  const scopeNode = scope.createNode(ac)\n  const scopeCanvas = document.createElement('canvas')\n  scopeCanvas.style = 'width: 50vw; height: 50vh;'\n  document.body.appendChild(scopeCanvas)\n\n  // ----\n\n  const waveNode = wave.createNode(ac)\n  const waveCanvas = document.createElement('canvas')\n  waveCanvas.style = 'width: 50vw; height: 50vh; background-color: hsl(260, 80%, 20%);'\n  document.body.appendChild(waveCanvas)\n\n  // ----\n\n  const oscNode = oscScope.createNode(ac)\n  const oscCanvas = document.createElement('canvas')\n  oscCanvas.style = 'width: 50vw; height: 50vh;'\n  document.body.appendChild(oscCanvas)\n\n  return {\n    sonogramNode,\n    sonogramCanvas,\n    scopeNode,\n    scopeCanvas,\n    waveNode,\n    waveCanvas,\n    oscNode,\n    oscCanvas\n  }\n}\n\nsetup.connect = function (nodes, input) {\n  const {\n    sonogramNode,\n    scopeNode,\n    waveNode,\n    oscNode\n  } = nodes\n\n  const all = [ \n    sonogramNode,\n    scopeNode,\n    waveNode,\n    oscNode\n  ]\n  all.forEach(n => input.connect(n))\n}\n\nsetup.startRenderLoop = function (nodes) {\n  const {\n    sonogramNode,\n    sonogramCanvas,\n    scopeNode,\n    scopeCanvas,\n    waveNode,\n    waveCanvas,\n    oscNode,\n    oscCanvas\n  } = nodes\n\n  let animFrameId\n  hp(() => {\n    if (animFrameId) { cancelAnimationFrame(animFrameId) }\n  \n    // ----\n\n    const renderSonogram = sonogram.createRenderFunc(sonogramNode, sonogramCanvas)\n    const renderScope = scope.createRenderFunc(scopeNode, scopeCanvas)\n    const renderWave = wave.createRenderFunc(waveNode, waveCanvas)\n    const renderOscScope = oscScope.createRenderFunc(oscNode, oscCanvas)\n    \n    function render () {\n      renderSonogram()\n      renderScope()\n      renderWave()\n      renderOscScope()\n      \n      animFrameId = requestAnimationFrame(render)\n    }\n    \n    render()\n  })\n}\n\nmodule.exports = setup\n","const hp = require('hot-pockets')\nconst setParams = require('./setParams')\nconst connectAll = require('./connectAll')\nconst beatEmitter = require('beat-emitter')\nconst Tuna = require('tunajs')\nconst rand = require('./rand')\n\nconst noise = require('./noise')\n\nconst ac = new AudioContext()\nconst tuna = new Tuna(ac)\nconst beats = beatEmitter(ac)\n\nbeats.setBpm(100)\nbeats.start()\n\n// ----\n\nvar limiter = setParams(ac.createDynamicsCompressor(), {\n  threshold: 0,\n  knee: 0,\n  ratio: 10,\n  attack: 0.005,\n  release: 0.050\n})\n\nlimiter.connect(ac.destination)\n\nconst panLeft = new tuna.Panner({\n  pan: -.4\n})\n\nconst panRight = new tuna.Panner({\n  pan: .4\n})\n\npanLeft.connect(limiter)\npanRight.connect(limiter)\n\n// ----\n\nconst viz = require('./viz')\nconst vizNodes = viz(ac)\n\nviz.connect(vizNodes, limiter)\nviz.startRenderLoop(vizNodes)\n\n// ----\n\nconst mixer = createMixer(ac, limiter, [\n  'noise',\n  'noise2'\n])\n\nmixer.noise.disconnect()\nmixer.noise.connect(panLeft)\n\nmixer.noise2.disconnect()\nmixer.noise2.connect(panRight)\n\nnoise({ \n  ac,\n  dest: mixer.noise,\n  beats, \n  tuna\n})\n\nnoise({ \n  ac,\n  dest: mixer.noise2,\n  beats, \n  tuna\n})\n\nhp(() => {\n  updateMixer(mixer, {\n    noise: 4.0,\n    noise2: 4.0\n  })\n})\n\nfunction createMixer (ac, dest, names) {\n  const nodes = {}\n  names.forEach(key => {\n    nodes[key] = ac.createGain()\n    nodes[key].connect(dest)\n  })\n  return nodes\n}\n\nfunction updateMixer (nodesByKey, gainsByKey, transitionTime = 1) {\n  Object.keys(gainsByKey).forEach(key => {\n    const zero = 0.000001\n    const time = ac.currentTime\n    const param = nodesByKey[key].gain\n    const value = gainsByKey[key]\n\n    param.cancelScheduledValues(time)\n    param.exponentialRampToValueAtTime(value || zero, time + transitionTime)\n  })\n}\n"]}